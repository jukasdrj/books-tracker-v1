# Swift 6.2 Improvements for WebSocket Implementation

**Date:** October 17, 2025
**Based on:** Swift 6.2 release (https://www.swift.org/blog/swift-6.2-released/)

## Key Swift 6.2 Features Applicable to Our Code

### 1. Typed Throws (Swift 6.0+, Enhanced in 6.2)

**Current Pattern (Generic Throws):**
```swift
// BookshelfAIService.swift
func processBookshelfImageWithWebSocket(
    _ image: UIImage,
    progressHandler: @MainActor @escaping (Double, String) -> Void
) async throws -> ([DetectedBook], [SuggestionViewModel]) {
    // Generic Error type - caller doesn't know what to catch
}
```

**Improved Pattern (Typed Throws):**
```swift
// BookshelfAIService.swift
func processBookshelfImageWithWebSocket(
    _ image: UIImage,
    progressHandler: @MainActor @escaping (Double, String) -> Void
) async throws(BookshelfAIError) -> ([DetectedBook], [SuggestionViewModel]) {
    // Caller knows exactly what errors can occur
    // Compiler enforces exhaustive error handling
}
```

**Benefits:**
- Compiler verifies exhaustive error handling
- Better autocomplete for catch blocks
- Self-documenting API (errors are part of signature)
- Type-safe error propagation

**Implementation:**
```swift
// Step 1: Make BookshelfAIError conform to Error (already done)
enum BookshelfAIError: Error, LocalizedError { ... }

// Step 2: Update all throws declarations
actor BookshelfAIService {
    func processBookshelfImageWithWebSocket(
        _ image: UIImage,
        progressHandler: @MainActor @escaping (Double, String) -> Void
    ) async throws(BookshelfAIError) -> ([DetectedBook], [SuggestionViewModel])

    private func uploadImage(_ imageData: Data) async throws(BookshelfAIError) -> BookshelfAIResponse

    private func startScanJob(_ imageData: Data) async throws(BookshelfAIError) -> ScanJobResponse

    func pollJobStatus(jobId: String) async throws(BookshelfAIError) -> JobStatusResponse
}

// Step 3: Call sites get better error handling
do {
    let (books, suggestions) = try await service.processBookshelfImageWithWebSocket(image) { ... }
} catch let error as BookshelfAIError {
    // Compiler knows this is exhaustive!
    switch error {
    case .imageCompressionFailed:
        showError("Failed to prepare image")
    case .networkError(let underlying):
        showError("Network issue: \(underlying)")
    case .serverError(let code, let message):
        showError("Server error \(code): \(message)")
    // ... handle all cases
    }
}
```

---

### 2. Intuitive Async Functions (Swift 6.2)

**What Changed:**
- Async functions now run in caller's execution context by default
- Previously always switched to global executor
- Reduces unnecessary actor hops

**Impact on Our Code:**

**Current WebSocketProgressManager:**
```swift
@MainActor
public final class WebSocketProgressManager: ObservableObject {
    public func connect(
        jobId: String,
        progressHandler: @escaping (JobProgress) -> Void
    ) async {
        // Already @MainActor, so this stays on MainActor
    }
}
```

**Calling from Actor:**
```swift
// BookshelfAIService.swift
actor BookshelfAIService {
    func processBookshelfImageWithWebSocket(...) async throws {
        // Create manager on MainActor
        let wsManager = await MainActor.run {
            WebSocketProgressManager()
        }

        // Connect (automatically hops to MainActor, then returns to actor)
        await wsManager.connect(jobId: jobId) { jobProgress in
            // This closure runs on MainActor (wsManager's isolation)
            progressHandler(percentage, stage)
        }
    }
}
```

**No Changes Needed:** Our pattern is already correct! Swift 6.2's intuitive async functions make the actor hops more efficient under the hood.

---

### 3. Observation Streaming (Swift 6.2)

**New Feature:** `Observations` async sequence for type-safe state change tracking

**Current Pattern (Callback Closures):**
```swift
func processBookshelfImageWithWebSocket(
    _ image: UIImage,
    progressHandler: @MainActor @escaping (Double, String) -> Void
) async throws -> ([DetectedBook], [SuggestionViewModel])
```

**Potential Observation Pattern:**
```swift
// WebSocketProgressManager with Observation streaming
@MainActor
@Observable
public final class WebSocketProgressManager {
    private(set) var progress: JobProgress?

    // Expose observations async sequence
    public var progressUpdates: some AsyncSequence<JobProgress, Never> {
        Observations(of: \.progress, on: self)
    }
}

// Usage in BookshelfAIService
actor BookshelfAIService {
    func processBookshelfImageWithWebSocket(
        _ image: UIImage
    ) async throws -> AsyncStream<(Double, String, [DetectedBook]?, [SuggestionViewModel]?)> {

        let wsManager = await MainActor.run { WebSocketProgressManager() }
        await wsManager.connect(jobId: jobId)

        return AsyncStream { continuation in
            Task {
                for await progress in await wsManager.progressUpdates {
                    let percentage = Double(progress.processedItems) / Double(progress.totalItems)
                    continuation.yield((percentage, progress.currentStatus, nil, nil))
                }

                // Fetch final result
                let result = try await self.waitForJobCompletion(jobId: jobId)
                continuation.yield((1.0, "Complete", detectedBooks, suggestions))
                continuation.finish()
            }
        }
    }
}
```

**Recommendation:** **DON'T MIGRATE YET**
- Callback pattern is simpler and well-understood
- Observation streaming adds complexity for minimal benefit here
- Better suited for complex multi-property state changes
- Current API is more ergonomic for one-directional progress flow

---

### 4. Modern NotificationCenter (Swift 6.2)

**New Feature:** Type-safe notifications with `MainActorMessage` and `AsyncMessage`

**Current Usage:** We don't use NotificationCenter for WebSocket progress

**Potential Use Case:** Background enrichment completion notifications

**Example (If We Needed It):**
```swift
// Define type-safe notification
extension Notification.Name {
    static let enrichmentComplete = Notification.Name("enrichmentComplete")
}

struct EnrichmentCompleteMessage: MainActorMessage {
    let jobId: String
    let bookCount: Int
}

// Post notification (automatically MainActor-isolated)
NotificationCenter.default.post(EnrichmentCompleteMessage(jobId: "...", bookCount: 12))

// Receive notification (type-safe!)
for await message in NotificationCenter.default.notifications(named: .enrichmentComplete,
                                                              object: nil)
                                                .compactMap({ $0 as? EnrichmentCompleteMessage }) {
    print("Enriched \(message.bookCount) books for job \(message.jobId)")
}
```

**Recommendation:** **NOT APPLICABLE**
- WebSocket already provides real-time updates
- No need for NotificationCenter-based messaging
- Keep current WebSocket pattern

---

### 5. Memory Safety: Span Type (Swift 6.2)

**What It Does:** Compile-time memory safety for contiguous data access

**Potential Application:** Image data handling

**Current Pattern:**
```swift
nonisolated private func compressImage(_ image: UIImage, maxSizeBytes: Int) -> Data? {
    // Returns Data (heap-allocated)
    return resizedImage.jpegData(compressionQuality: quality)
}
```

**Span Pattern (Future Optimization):**
```swift
// Hypothetical future optimization
nonisolated private func compressImage(_ image: UIImage, maxSizeBytes: Int) -> Span<UInt8> {
    // Return stack-based span instead of heap Data
    // Eliminates allocation for large JPEG data
}
```

**Recommendation:** **NOT WORTH IT YET**
- `Data` is well-optimized by Foundation
- Span is for low-level systems programming
- Image compression already handles memory efficiently
- Premature optimization for this use case

---

### 6. Subprocess Package (Swift 6.2)

**What It Does:** Type-safe process launching with async/await

**Applicability:** **NONE**
- We don't launch external processes
- WebSocket communication is URLSession-based
- No shell commands or subprocesses in our code

---

## Recommended Changes to WebSocket Plan

### HIGH PRIORITY: Add Typed Throws

**Files to Update:**
1. `BookshelfAIService.swift` - All `throws` → `throws(BookshelfAIError)`
2. `WebSocketProgressManager.swift` - Add `WebSocketError` enum, use typed throws
3. Plan Task 3 - Update method signature examples

**Benefits:**
- Self-documenting error handling
- Compiler-verified exhaustive catches
- Better IDE autocomplete

**Implementation:**
```swift
// Add to WebSocketProgressManager.swift
enum WebSocketError: Error, LocalizedError {
    case connectionFailed(URLError)
    case invalidJobId
    case messageDecodingFailed(Error)
    case disconnected

    var errorDescription: String? {
        switch self {
        case .connectionFailed(let error):
            return "WebSocket connection failed: \(error.localizedDescription)"
        case .invalidJobId:
            return "Invalid or empty job ID"
        case .messageDecodingFailed(let error):
            return "Failed to decode progress message: \(error.localizedDescription)"
        case .disconnected:
            return "WebSocket disconnected unexpectedly"
        }
    }
}

@MainActor
public final class WebSocketProgressManager: ObservableObject {
    public func connect(
        jobId: String,
        progressHandler: @escaping (JobProgress) -> Void
    ) async throws(WebSocketError) {
        guard !jobId.isEmpty else {
            throw .invalidJobId
        }
        // ... rest of implementation
    }
}
```

### MEDIUM PRIORITY: Document Swift 6.2 Benefits

**Update CHANGELOG.md:**
```markdown
### Swift 6.2 Language Features

**Typed Throws:**
- All WebSocket and AI service methods use `throws(ErrorType)` syntax
- Compiler-verified exhaustive error handling
- Self-documenting API contracts

**Intuitive Async Functions:**
- Automatic execution context preservation
- Reduced actor hops for WebSocket → MainActor communication
- Zero manual actor isolation annotations needed
```

### LOW PRIORITY: Future Explorations

**Observation Streaming (Defer to v2):**
- Consider for complex multi-stage workflows
- Current callback pattern is simpler for progress updates
- Revisit when adding multi-book parallel enrichment

**Span Type (Not Applicable):**
- Image compression already optimized
- No measurable benefit for our use case
- Keep using `Data` type

---

## Updated Implementation Plan Changes

### Task 3: Add WebSocket Method to BookshelfAIService

**Change Step 3 signature to:**
```swift
func processBookshelfImageWithWebSocket(
    _ image: UIImage,
    progressHandler: @MainActor @escaping (Double, String) -> Void
) async throws(BookshelfAIError) -> ([DetectedBook], [SuggestionViewModel]) {
    // Typed throws ensures caller knows exactly what errors to handle
}
```

**Add error handling documentation:**
```swift
/// Errors thrown:
/// - `.imageCompressionFailed`: Image could not be compressed
/// - `.networkError`: Network connectivity issue
/// - `.serverError`: Backend processing failed
/// - `.invalidResponse`: Malformed response from server
/// - `.decodingFailed`: JSON parsing error
/// - `.imageQualityRejected`: Image quality too poor for AI analysis
```

### Task 4: Update Error Handling in BookshelfScannerView

**Add typed error handling:**
```swift
do {
    let (detectedBooks, suggestions) = try await BookshelfAIService.shared
        .processBookshelfImageWithWebSocket(image, progressHandler: { ... })

} catch let error as BookshelfAIError {
    // Compiler verifies this is exhaustive
    switch error {
    case .imageCompressionFailed:
        errorMessage = "Failed to prepare image. Try a different photo."
    case .networkError:
        errorMessage = "Network error. Check your connection and try again."
    case .serverError(let code, let message):
        errorMessage = "Server error (\(code)): \(message)"
    case .imageQualityRejected(let reason):
        errorMessage = "Image quality issue: \(reason)"
    case .invalidResponse, .decodingFailed:
        errorMessage = "Unexpected response from server. Please try again."
    }
}
```

---

## Summary

**Apply These Swift 6.2 Features:**
1. ✅ **Typed Throws** - HIGH PRIORITY (add to plan)
2. ✅ **Intuitive Async** - Already correct! (no changes needed)
3. ❌ **Observation Streaming** - Defer to future (callback pattern is simpler)
4. ❌ **Modern NotificationCenter** - Not applicable (WebSocket handles messaging)
5. ❌ **Span Type** - Not worth it (Data is already optimized)
6. ❌ **Subprocess** - Not applicable (no process launching)

**Verdict:** Our WebSocket plan is **already well-aligned** with Swift 6.2 best practices. Only improvement needed is **typed throws** for better error handling documentation and compiler verification.
